#include "SceneSerializer.h"

#include <Engine/Project/Entities/EntityManager.h>
#include <Engine/Project/Entities/SceneEntity.h>

#include <codecvt>
#include <fstream>
#include <yaml-cpp/yaml.h>

#define KEY_NAME        "Name"
#define KEY_ID          "ID"
#define KEY_ENTITIES    "Entities"

namespace Shell::Editor {

    inline YAML::Emitter& operator<<(YAML::Emitter& emitter, SceneEntity * entity) {

        emitter << YAML::BeginMap;

        emitter << YAML::Key << KEY_NAME;
        emitter << YAML::Value << entity->GetName();

        emitter << YAML::Key << KEY_ID;
        emitter << YAML::Value << UuidToString(entity->GetUuid());

        if (entity->HasChildren()) {
            emitter << YAML::Key << "Children";
            emitter << YAML::BeginSeq;

            for (const auto &childEntity: entity->GetChildren()) {
                emitter << childEntity;
            }

            emitter << YAML::EndSeq;
        }

        emitter << YAML::EndMap;

        return emitter;
    }

    void SceneSerializer::SerializeToFile(const std::filesystem::path &path, const Ref<SceneBlueprint>& sceneBlueprint) {

        YAML::Emitter out;
        out << YAML::Comment("This file is automatically generated by the editor, do not modify it!");
        out << YAML::BeginMap;

        out << YAML::Key << KEY_NAME;
        out << YAML::Value << sceneBlueprint->GetName();

        out << YAML::Key << KEY_ID;
        out << YAML::Value << UuidToString(sceneBlueprint->GetUuid());

        out << YAML::Key << KEY_ENTITIES;
        out << YAML::Value;

        out << YAML::BeginSeq;

        for (const auto &entity: sceneBlueprint->GetEntityTree()) {
            out << entity;
        }

        out << YAML::EndSeq;

        out << YAML::EndMap;

        std::ofstream projectFile(path);
        projectFile << out.c_str();
    }

    Ref <SceneBlueprint> SceneSerializer::DeserializeFromFile(const std::filesystem::path &path) {
        SHELL_INFO("Try loading scene");
        YAML::Node config = YAML::LoadFile(path.generic_string());

        if (!config[KEY_NAME]) {
            SHELL_WARN("Could not read {0} from scene file", KEY_NAME);
            return nullptr;
        }

        if (!config[KEY_ID]) {
            SHELL_WARN("Could not read {0} from scene file", KEY_ID);
            return nullptr;
        }

        if (!config[KEY_ENTITIES]) {
            SHELL_WARN("Could not read {0} from scene file", KEY_ENTITIES);
            return nullptr;
        }

        auto sceneName = config[KEY_NAME].as<std::string>();
        auto sceneID = Uuid::Create(config[KEY_ID].as<std::string>());
        auto bluePrint = CreateRef<SceneBlueprint>(sceneName, sceneID);

        auto entities = config[KEY_ENTITIES];
        for(YAML::const_iterator it = entities.begin(); it != entities.end(); ++it) {
            auto entity = it->as<YAML::Node>();

            if (!entity[KEY_NAME]) {
                SHELL_WARN("Could not read {0} from scene entity", KEY_NAME);
                return nullptr;
            }

            if (!entity[KEY_ID]) {
                SHELL_WARN("Could not read {0} from scene entity", KEY_ID);
                return nullptr;
            }

            auto entityName = entity[KEY_NAME].as<std::string>();
            auto entityID = Uuid::Create(entity[KEY_ID].as<std::string>());
            SceneEntity * sceneEntity = EntityManager::Instance()->CreateEntity(bluePrint, entityName, entityID);
            bluePrint->AddEntity(sceneEntity);
        }

        return bluePrint;
    }
}